{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + inspect(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + inspect(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + inspect(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return objectIntrospection.interfaces.map(getInterfaceType);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + inspect(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + inspect(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + inspect(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + inspect(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + inspect(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + inspect(directiveIntrospection));\n    }\n\n    if (!directiveIntrospection.locations) {\n      throw new Error('Introspection result missing directive locations: ' + inspect(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}","map":{"version":3,"sources":["C:/Users/K. C. Fike/Desktop/github/productapp/node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["inspect","invariant","keyMap","keyValMap","valueFromAST","parseValue","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","buildClientSchema","introspection","options","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","concat","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","getOutputType","getObjectType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","serialize","value","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","buildDirective","directiveIntrospection","locations","slice","queryType","mutationType","subscriptionType","directives","query","mutation","subscription","assumeValid","allowedLegacyNames"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + inspect(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + inspect(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + inspect(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return objectIntrospection.interfaces.map(getInterfaceType);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + inspect(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + inspect(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + inspect(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + inspect(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + inspect(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + inspect(directiveIntrospection));\n    }\n\n    if (!directiveIntrospection.locations) {\n      throw new Error('Introspection result missing directive locations: ' + inspect(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}"]},"metadata":{},"sourceType":"module"}